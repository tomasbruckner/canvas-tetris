<html>

<body>
  <button id="idPlayButton" onClick="play();">Play</button>
  <audio id="idMusic" src='Tetris.ogg' loop></audio>
  <canvas id='idCanvas' height='900px' width='900px'>
  </canvas>

  <script>
    const CUBE_SIZE = 30;
    const WIDTH_IN_CUBES = 10;
    const HEIGHT_IN_CUBES = 20;

    function getCoords({ x: relativeX, y: relativeY, coordsByRotation, rotation }) {
      return coordsByRotation[rotation].map(({ x, y }) => ({ x: x + relativeX, y: y + relativeY }))
    }

    function checkGameOver(space, currentElement) {
      if (hasCollisions(space, currentElement)) {
        gameOver();
      }
    }

    function gameOver() {
      clearInterval(intervalHandler);
      intervalHandler = null;
      console.log('game over');
    }

    function updateScore(linesCleared) {
      
    }

    function hasCollisions(space, newElement) {
      const newCoord = getCoords(newElement);
      const maxY = Math.max(...newCoord.map(({ y }) => y));
      const isLastLine = maxY === CUBE_SIZE * (HEIGHT_IN_CUBES);

      if (isLastLine) {
        return true;
      }

      for (const { x: newX, y: newY } of newCoord) {
        if (space[newY].some(({ x }) => x === newX)) {
          return true;
        }
      }

      return false;
    }

    function renderElement({ color }, coords, ctx) {
      ctx.fillStyle = color;

      for (const { x, y } of coords) {
        ctx.fillRect(x, y, CUBE_SIZE, CUBE_SIZE);
      }
    }

    function renderLayout(canvas, ctx) {
      ctx.beginPath();
      ctx.moveTo(0, 0);

      for (let i = 0; i <= WIDTH_IN_CUBES; i++) {
        ctx.lineTo(i * CUBE_SIZE, CUBE_SIZE * HEIGHT_IN_CUBES);
        ctx.moveTo((i + 1) * CUBE_SIZE, 0);
      }

      ctx.moveTo(0, 0);
      for (let i = 0; i <= HEIGHT_IN_CUBES; i++) {
        ctx.lineTo(CUBE_SIZE * WIDTH_IN_CUBES, i * CUBE_SIZE);
        ctx.moveTo(0, (i + 1) * CUBE_SIZE);
      }

      ctx.stroke();
    }

    function renderSpace(space, canvas, ctx) {
      for (const [y, line] of Object.entries(space)) {
        for (const { x, color } of line) {
          ctx.fillStyle = color;
          ctx.fillRect(x, y, CUBE_SIZE, CUBE_SIZE);
        }
      }
    }

    function render(space, currentElement, canvas, ctx) {
      const coord = getCoords(currentElement);

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      renderLayout(canvas, ctx);
      renderSpace(space, canvas, ctx);
      renderElement(currentElement, coord, ctx);
    }

    function generateNewElement() {
      const elementIndex = Math.floor(Math.random() * Elements.length);
      const newElement = {
        ...Elements[elementIndex],
      };

      currentElement = newElement;

      return currentElement;
    }

    function clearFullLines(space) {
      const clearedLines = [];
      for (const [y, line] of Object.entries(space)) {
        if (line.length === WIDTH_IN_CUBES) {
          space[y] = [];
          clearedLines.push(y);
        }
      }

      if (clearedLines.length) {
        clearedLines.reverse();

        for (const y of clearedLines) {
          for (let i = y; i >= 0; i -= CUBE_SIZE) {
            space[i] = space[i - CUBE_SIZE] || [];
          }
        }
      }
    }

    function moveElementDown(space) {
      const newElement = { ...currentElement, y: currentElement.y + CUBE_SIZE };

      if (hasCollisions(space, newElement)) {
        const coord = getCoords(currentElement);
        for (const { x, y } of coord) {
          space[y].push({ x, color: currentElement.color });
        }

        clearFullLines(space);
        const newCurrentElement = generateNewElement();
        checkGameOver(space, newCurrentElement);

        return false;
      }

      currentElement = newElement;
      return true;
    }

    function moveElementBottom(space, currentElement) {
      while (moveElementDown(space, currentElement));
    }

    function setNewElement(space, newElement) {
      const newCoord = getCoords(newElement);

      for (const { x, y } of newCoord) {
        if (x < 0 || x > CUBE_SIZE * (WIDTH_IN_CUBES - 1) || y < 0 || y > CUBE_SIZE * (HEIGHT_IN_CUBES - 1)) {
          return false;
        }
      }

      if (!hasCollisions(space, newElement)) {
        currentElement = newElement;
      }

      return true;
    }

    function generateSpace(height) {
      const space = {};

      for (let i = 0; i <= height; i++) {
        space[i * CUBE_SIZE] = [];
      }

      return space;
    }

    const ElementTypes = {
      T: 'T',
      Line: 'Line',
      L: 'L',
      ReverseL: 'ReverseL',
      Square: 'Square',
      Squiggly: 'Squiggly',
      ReverseSquiggly: 'ReverseSquiggly',
    };

    const Elements = [{
      type: ElementTypes.T,
      color: 'purple',
      x: 120,
      y: 0,
      rotation: 0,
      coordsByRotation: {
        0: [{ x: 30, y: 0 }, { x: 0, y: 30 }, { x: 30, y: 30 }, { x: 60, y: 30 }],
        90: [{ x: 30, y: 0 }, { x: 30, y: 30 }, { x: 30, y: 60 }, { x: 60, y: 30 }],
        180: [{ x: 30, y: 60 }, { x: 0, y: 30 }, { x: 30, y: 30 }, { x: 60, y: 30 }],
        270: [{ x: 30, y: 0 }, { x: 30, y: 30 }, { x: 30, y: 60 }, { x: 0, y: 30 }],
      },
    }, {
      type: ElementTypes.Line,
      color: 'aqua',
      x: 120,
      y: 0,
      rotation: 0,
      coordsByRotation: {
        0: [{ x: 30, y: 0 }, { x: 30, y: 30 }, { x: 30, y: 60 }, { x: 30, y: 90 }],
        90: [{ x: 0, y: 30 }, { x: 30, y: 30 }, { x: 60, y: 30 }, { x: 90, y: 30 }],
        180: [{ x: 60, y: 0 }, { x: 60, y: 30 }, { x: 60, y: 60 }, { x: 60, y: 90 }],
        270: [{ x: 0, y: 60 }, { x: 30, y: 60 }, { x: 60, y: 60 }, { x: 90, y: 60 }],
      },
    }, {
      type: ElementTypes.L,
      color: 'yellow',
      x: 120,
      y: 0,
      rotation: 0,
      coordsByRotation: {
        0: [{ x: 0, y: 0 }, { x: 0, y: 30 }, { x: 0, y: 60 }, { x: 30, y: 60 }],
        90: [{ x: 0, y: 0 }, { x: 30, y: 0 }, { x: 60, y: 0 }, { x: 0, y: 30 }],
        180: [{ x: 30, y: 0 }, { x: 60, y: 0 }, { x: 60, y: 30 }, { x: 60, y: 60 }],
        270: [{ x: 60, y: 30 }, { x: 0, y: 60 }, { x: 30, y: 60 }, { x: 60, y: 60 }],
      },
    }, {
      type: ElementTypes.ReverseL,
      color: 'blue',
      x: 120,
      y: 0,
      rotation: 0,
      coordsByRotation: {
        0: [{ x: 30, y: 0 }, { x: 30, y: 30 }, { x: 30, y: 60 }, { x: 0, y: 60 }],
        90: [{ x: 0, y: 30 }, { x: 0, y: 60 }, { x: 30, y: 60 }, { x: 60, y: 60 }],
        180: [{ x: 0, y: 0 }, { x: 30, y: 0 }, { x: 0, y: 30 }, { x: 0, y: 60 }],
        270: [{ x: 0, y: 0 }, { x: 30, y: 0 }, { x: 60, y: 0 }, { x: 60, y: 30 }],
      },
    }, {
      type: ElementTypes.Square,
      color: 'brown',
      x: 120,
      y: 0,
      rotation: 0,
      coordsByRotation: {
        0: [{ x: 0, y: 0 }, { x: 0, y: 30 }, { x: 30, y: 30 }, { x: 30, y: 0 }],
        90: [{ x: 0, y: 0 }, { x: 0, y: 30 }, { x: 30, y: 30 }, { x: 30, y: 0 }],
        180: [{ x: 0, y: 0 }, { x: 0, y: 30 }, { x: 30, y: 30 }, { x: 30, y: 0 }],
        270: [{ x: 0, y: 0 }, { x: 0, y: 30 }, { x: 30, y: 30 }, { x: 30, y: 0 }],
      },
    }, {
      type: ElementTypes.Squiggly,
      color: 'green',
      x: 120,
      y: 0,
      rotation: 0,
      coordsByRotation: {
        0: [{ x: 0, y: 60 }, { x: 30, y: 60 }, { x: 30, y: 30 }, { x: 60, y: 30 }],
        90: [{ x: 0, y: 0 }, { x: 0, y: 30 }, { x: 30, y: 30 }, { x: 30, y: 60 }],
        180: [{ x: 0, y: 60 }, { x: 30, y: 60 }, { x: 30, y: 30 }, { x: 60, y: 30 }],
        270: [{ x: 0, y: 0 }, { x: 0, y: 30 }, { x: 30, y: 30 }, { x: 30, y: 60 }],
      },
    }, {
      type: ElementTypes.ReverseSquiggly,
      color: 'red',
      x: 120,
      y: 0,
      rotation: 0,
      coordsByRotation: {
        0: [{ x: 0, y: 30 }, { x: 30, y: 30 }, { x: 30, y: 60 }, { x: 60, y: 60 }],
        90: [{ x: 30, y: 0 }, { x: 30, y: 30 }, { x: 0, y: 30 }, { x: 0, y: 60 }],
        180: [{ x: 0, y: 30 }, { x: 30, y: 30 }, { x: 30, y: 60 }, { x: 60, y: 60 }],
        270: [{ x: 30, y: 0 }, { x: 30, y: 30 }, { x: 0, y: 30 }, { x: 0, y: 60 }],
      },
    },
    ];

    const space = generateSpace(HEIGHT_IN_CUBES);
    let canvas;
    let ctx;
    let currentElement;
    let intervalHandler;
    let score = 0;
    let level = 1;

    window.onload = function() {
      currentElement = generateNewElement();
      canvas = document.getElementById('idCanvas');
      ctx = canvas.getContext('2d');

      document.onkeyup = ({ key }) => {
        if (!intervalHandler) {
          return;
        }  

        if (key === 'ArrowUp') {
          setNewElement(space, { ...currentElement, rotation: (currentElement.rotation + 90) % 360 });
        } else if (key === 'ArrowLeft') {
          setNewElement(space, { ...currentElement, x: currentElement.x - CUBE_SIZE });
        } else if (key === 'ArrowRight') {
          setNewElement(space, { ...currentElement, x: currentElement.x + CUBE_SIZE });
        } else if (key === 'ArrowDown') {
          moveElementDown(space, currentElement);
        } else if (key === ' ') {
          moveElementBottom(space, currentElement);
        } else {
          console.log(key)
        }

        render(space, currentElement, canvas, ctx);
      }
    }

    function play() {
      document.getElementById('idPlayButton').remove();
      document.getElementById('idMusic').play();
      intervalHandler = setInterval(function () {
        moveElementDown(space, currentElement);
        render(space, currentElement, canvas, ctx);
      }, 1000);
    }
  </script>
</body>

</html>
